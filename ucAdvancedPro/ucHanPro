1. vfork和fork的区别：
	vfork与fork一样都创建一个子进程，但是他不将父进程的地址空间完全复制到自己程中，
因为子进程会立即调用exec或exit，于是也就不会访问该地址空间。
	vfork会保证子进程先运行，在它调用exec或exit之后父进程可能被调度。
	（如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁）
使用vfork的时候，父进程就不用再调用sleep了，因为vfork已经保证了在子进程调用exec或exit之前，
内核，会使父进程处于休眠状态。

大多数exit现代实现不再在流的关闭方面自找麻烦。因为进程即将终止，那时内核将关闭在进程中已打开的
所有文件描述符。在库中关闭他们，只是增加了开销，而不会带来任何益处。

2.exit函数
	在main函数内执行return语句，等效于调用exit
	调用exit函数，它由ISO C定义，其操作包括调用各个终止处理程序(调用atexit登记)，然后
   关闭所有标准I/O流等。但是ISO C并不处理文件描述符、多进程以及作业控制。
   内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到这
些信息。
   init不会产生僵尸进程，因为init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数
取得其终止状态。
   不管进程如何终止，最后都会执行内核中的一段代码。这段代码为相应进程关闭所有打开的描述符，释放它所使
用的存储器等资源。
   不管父进程怎样终止，我们都希望终止进程能够通知其父进程它是如何终止的。对于三个终止函数(exit,_exit,_Exit),实现方法是，
将其退出状态exit status作为参数传递给函数。在异常终止情况下，内核(不是进程本身)产生一个指示其异常终止的原因(终止状态
termination status).在任意一种情况下，该终止进程的父进程都能使用wait，waitpid取得其终止状态。
注意：使用了“退出状态”和“终止状态”的区别。在最后调用_exit时，内核将退出状态转换成终止状态。
   孤儿进程的产生：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则将该进程的父进程
ID改成1(init)。这种方法保证了每个进程都只有一个父进程。
   僵尸进程：
      当子进程先于父进程结束的时候，父进程又如何获得相应的子进程终止状态那？
      内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到这些信息。内核可以释放终止
进程所使用的所有存储区，关闭其所有打开的文件。


3.wait/waitpid函数
    当一个进程正常或异常终止的时候，“内核”就向其父进程发送SIGCHLD信号。因为子进程终止是个异步事件(可以在父进程运行的任何时候发生)，
所以这种信号也是内核向父进程发的异步通知。父进程可以忽略改信号，或则定义一个SIGCHLD处理函数。
   大多数UNIX系统实现了提供另外两个函数wait3/wait4。这2时从BSD分支沿袭下来的。他们提供额外的功能：要求内核返回由终止进程及其所有子进程
使用的资源汇总。包括用户CPU时间总量，系统CPU时间总量，页面出错次数，接收到信号的次数等。

4.竞争条件
	当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了“竞争条件race condition”。
	如果一个进程想要等待父进程终止：
	while(getppid()!=1)
	    sleep(1);
	    这种方式称为轮询polling。浪费CPU时间。
为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号发送和接收的方法。

5.更改用户ID和组ID
	在UNIX系统中，特权(读写执行等)是基于“用户和组ID”的。当程序需要增加特权，或需要访问当前并不允许访问的资源时，我们需要更换自己
的用户ID或组ID，使得新ID具有合适的访问权限。可以使用setuid()设置实际用户ID和有效用户ID。setgid()函数设置实际组ID和有效组ID。
 
    实际用户ID是用户在登陆时，有login程序设置的，而且永远不会改变它。
    setreuid()/setregid() 功能是：交换实际用户ID和有效用户ID的值。
    seteuid()/setegid()  :更改有效用户ID和有效组ID

6.system()
	system()函数和fork/exec相比的优点是：system进行了所需的各种错误处理，以及各种信号处理。
	
7.进程会计 process accounting
	 大多数UNIX系统提供了一个选项以进行进程会计处理，启用该选项后，阿米当进程结束时，内核就写一个会计记录。
典型的会计记录包含总量较小的二进制数据，一般包括命令名、CPU时间，用户ID等。
使用acct()函数可以启用或禁止该函数。但是，由于不同系统的不同实现，可能会出现不同的情况。
在linux下，该文件一般为/var/account/pacct。每次进程终止时都会编写一条会计记录。这就说明在会计文件中记录的顺序
对应于进程终止的顺序。

8.用户标识
	任意一进程都可以获得其实际和有效用户ID及组ID。
	getpwuid(getuid())：可以获得运行该程序的用户登录名。
	getlogin() :若成功则返回指向登录名字符串的指针。
	有了登录名，就可以使用getpwnam()在口令文件中查找用户相应的记录。

9.进程时间
	大多数实现都提供了getrusage()函数，该函数返回CPU时间，以及指示资源使用的情况。
       getrusage - get resource usage
SYNOPSIS
       #include <sys/time.h>
       #include <sys/resource.h>
       int getrusage(int who, struct rusage *usage);

=============================================================================
		9	进程关系  
       现代UNIX系统已发展到支持多身份验证过程，例如，FreeBSD,Linux,Mac OSX以及Solaris都支持
被成为PAM(Pluggable Authentication Module,可插入式身份验证模块)的更加灵活的方案。
       为了使统一个软件既能支持处理终端login，又能处理网络login，系统使用了一种成为“伪终端”pseudo terminal
的软件驱动程序，它仿真串行终端的运行行为，并将终端操作映射为网络操作。
	BSD中有意个成为“inetd”的进程，有时称为因特网超级服务器，它等待大多数网络链接。作为系统启动的一部分，init调用
一个shell，使其执行shell脚本/etc/rc；由此shell脚本启动一个守护进程inetd。一旦此shell脚本终止，inetd的父进程就变成
init。inetd等待TCP/IP链接请求的到来，而当一个链接请求到达时，他执行一次fork，然后生成子进程执行适当的程序。
	（说明了怎样启动一个进程作为服务进程）
1.进程组
	每个进程除了有意个PID之外，还有一个GID。一个进程组是一个或多个进程的集合。通常，他们与同一个作业相关联，
可以接受来自同一终端的各种信号。"getpgrp(void)"返回调用进程的进程组ID；
	setpgid, getpgid, setpgrp, getpgrp - set/get process group
 #include <unistd.h>
       int setpgid(pid_t pid, pid_t pgid);
       pid_t getpgid(pid_t pid);

       pid_t getpgrp(void);                /* POSIX.1 version */
       pid_t getpgrp(psid_t pid);          /* BSD version */

       int setpgrp(void);                  /* System V version */
       int setpgrp(pid_t pid, pid_t pgid); /* BSD version */
每一个进程组都有一个组长进程。组长进程的标识是，其进程ID等于其进程组ID。组长进程可以创建一个进程组，再创建
改组中的进程，然后终止。只要再某个进程组中有意个进程存在，则该进程组就存在，这于其组长进程是否终止无关。
进程组中的最后一个进程可以终止，或者转移到另一个进程组。
	setpgid()可以让调用进程加入一个现有组或者创建一个新的进程组。一个进程只能为自己和它的子进程设置进程组ID，
在它的子进程调用exec之后，它就不再能改变子进程的进程组ID。

2.会话 session
       会话是一个或多个进程组的集合。进程调用setsid()来建立一个新会话。挥发生下面3件事：
       1.该进程会变成“新会话首进程session leader”
       2.该进程灰尘呢个为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。
       3.该进程没有控制终端，如果在调用setsid之前该进程有一个控制终端，那么这种联系也会终端。
如果该调用进程已经是一个进程组的组长，则此函数会返回错误。为了保证不发生这种情况，通常先调用fork，
使父进程结束，而子进程继续。子进程肯定不会是组长，所以就可不会出现冲突。
       会话和进程组有一些其他特性：
       1.一个会话可以有一个控制终端
       2.一个会话中的几个进程组可被分成一个前台进程组，以及一个或几个后台进程组
       3.如果一个会话有一个控制终端，则他又一个前台进程组，其他则为后台进程组
       4.无论何时键入终端的中断键(ctrl+c)/退出键(ctrl+\),就会将中断/退出信号发送给前台进程组的所有进程
       5.如果终端接口检测到调制解调器或网络已经断开链接，则将进程挂断信号发送给控制进程(会话首进程)

3.控制终端
	有时不管标准输入、输出是否被重定向，程序都要与控制终端交互。保证程序能读写控制终端的方法是打开文件/dev/tty，
在内核中，此特殊文件是控制终端的同义语。自然，如果程序没有控制终端，则打开此设备将失败。

      tcgetpgrp,tcsetpgrp和tcgetsid()
 tcgetpgrp, tcsetpgrp - get and set terminal foreground process group
SYNOPSIS
       #include <unistd.h>
       pid_t tcgetpgrp(int fd);
       int tcsetpgrp(int fd, pid_t pgrp);
上面的函数用于获得/设置控制终端的前台进程组ID。

4.作业控制
作业控制是BSD在1980年前后增加的一个特性。它允许在一个终端上启动多个作业(进程组)，它控制那一个作业可以访问该终端，
以及那些作业在后台运行。作业控制要求下面3中形式的支持：
	1.支持作业控制的shell	
	2.内核中的终端驱动程序必须支持作业控制
	3.内核必须提供对某些作业控制信号的支持
	（POSIX.1选择了BSD形式的作业控制，POSIX.1要求系统要有作业控制）

5.shell执行程序
	其实shell执行命令的过程，就是一个很好的会话例子，期间有前台进程也有后台进程。

6.孤儿进程组

================================================================================
		10	信号
	信号是软件中断。信号提供了一种处理一部事件的方法。	
	
当执行一个程序时，所有的信号的状态都是系统默认或忽略。通常所有的信号都被设置成为他们的默认动作，除非调用exec的
进程忽略该信号。exec函数将原先设置为要捕捉的信号都改为它们默认的动作，其他信号状态则不改变。
比如shell自动将后台进程对中断和退出信号的处理方式设置为忽略，所以，当按下中断键时就不会影响到后台进程。
    当调用fork创建一个子进程时，子进程会继承父进程的信号处理方式。

1.不可靠的信号
    要注意，信号并不是绝对可靠的，在传递的过程中可能出现叠加或是丢失(早期的UNIX系统中)，尤其要注意，在信号产生
到调用signal的这一个时间窗口中，可能出现问题。

2.中断的系统调用
	UNIX系统一个特性就是：如果进程在执行一个低速“系统调用”而阻塞期间捕获了一个信号，则该系统调用就被中断且
不再继续执行。该系统调用出错，其errno被设置为EINTR。比如sleep，write，read等。注意：必须区分系统调用和函数。
当捕捉到某个信号时，被中断的是内核中执行的系统调用。
    为了支持这种特性，将系统调用分成两类：低速系统调用和其他系统调用。低速调用包括：
	 1.读写某些类型的文件(管道，终端设备以及网络设备)时，如果数据并不存在则可能会使调用者永远阻塞
	 2.在写这些文件时如果不能立即接受这些数据，可能会使调用者阻塞
	 3.pause()和wait()函数
	 4.某些ioctl操作
	 5.某些进程间通信函数
    在低速系统调用中，一个注意的例外是与磁盘I/O有关的系统调用，虽然，可能会进行等待，但是除非发生硬件错误，
I/O操作总会很快返回，并使调用者不再处于阻塞状态。

3.信号
	在信号产生 generation 和递送 delivery 之间的时间间隔内，称信号是未决的 pending.
	如果在进程解除对某个信号的阻塞之前，这种信号发生了多次，将会如何？
	     POSIX.1允许系统递送该信号一次或多次。如果递送该信号多次，则称对这些信号进行了排队。但是除非支持POSIX.1实时扩展，
	     否则大多数UNIX并不对信号排队。代之以UNIX内核只递送这种信号一次。
    每个进程都有一个信号屏蔽字 signal mask，它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号，该屏蔽字中都有一位与之对应。
    进程可以调用sigprocmask()来检测和更改其当前信号屏蔽字。POSIX.1定义了一个sigset_t，用于保存一个信号集。信号屏蔽字就存放在一个
sigset_t变量里面。
	信号量处理函数：
  sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX sig-
       nal set operations.
SYNOPSIS
       #include <signal.h>
       int sigemptyset(sigset_t *set);
       int sigfillset(sigset_t *set);
       int sigaddset(sigset_t *set, int signum);
       int sigdelset(sigset_t *set, int signum);
       int sigismember(const sigset_t *set, int signum);
       很多平台采用使用sigaction()来实现signal()

       当捕捉到一个信号时，进入信号处理函数，此时当前信号被自动地加到进程的信号屏蔽字中，这阻止了后来产生的这种信号
       被处理。
       一个信号屏蔽字规定了当前阻塞而不能传递给该进程的信号集，调用函数sigprocmask()可以检测或是更改其信号屏蔽字，
       或是在一个步骤中同时执行这两个函数。

	kill函数将信号发送到进程或进程组；raise函数则允许进程向自身发送信号。
	注意：UNIX系统在经过一段事件后会重新使用进程ID，所以一个现有的具有所给定进程ID的进程并不一定就是你想要的进程；
	      还应理解的是，对于进程是否存在的这种测试不是原子操作。在kill向调用者返回测试结果时，原来的被测试进程此时
	      可能已经终止了，所以这种测试并无多大价值。
	alarm()：每个进程只能有一个闹钟时钟。如果在调用alarm时，以前已为该进程设置过闹钟时钟，而且它还没有超过时，会被新值取代；
		 上次剩余的时间，作为返回值。
		 如果本次调用的参数为0，则会取消上次的定时。
        pause():函数使调用进程挂起直到捕捉的一个信号。只有执行了一个信号处理程序并从其返回是，pause()才返回。
	
	在信号处理函数中进行非局部转移时应当使用这两个函数进行跳转：
			sigsetjmp()/siglongjmp()
	因为当我们在信号处理函数中使用setjmp/longjmp的时候，由于此时该信号已经被加入到信号屏蔽字中，如果此时跳转
有可能该信号一直存在于信号屏蔽字中，以至于不能处理后续的信号。所以对于信号处理函数中的跳转需要使用专门的sigsetjmp()
siglongjmp().
	sigsuspend();

	abort()的功能是使异常程序终止。此函数将SIGABRT信号发送给调用进程(进程不应该忽略此信号)。ISO C规定，调用
abort将向主机环境递送一个未成功终止的通知，方法是raise(SIGABRT)函数。



=========================================================================================
			11	线程
	线程包含了表示进程内执行环境必须的信息，其中包括进程中标识线程的线程ID，一组寄存器值，栈，调度优先级和策略，信号屏蔽字，errno变量
以及线程私有的数据。
	进程的所有信息对该进程的所有线程都是共享的，包括可执行的程序文本、程序的全局内存和堆内存、栈以及文件描述符。
	线程ID类型是pthread_t，实现的时候可以用一个结构来代表，所以不应该直接用==来判断两个进程是否为同一个线程，应该使用：pthread_equal();
	线程可以调用pthread_cancel()函数来请求取消同一进程中的其他线程。pthread_cancel并不等待线程终止，它仅仅提出请求。
	线程可以安排它退出时需要调用的函数，称为：线程清理程序。，他们记录在栈里面，所以他们的执行顺序与他们注册的顺序相反：
			pthrad_cleanup_push()设置执行的清理函数；pthread_cleanup_pop()设置执取消执行的清理函数。

1.线程同步
	当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图。
        在变量修改时间多于一个存储器访问周期的处理器结构中，当存储器读与存储器写这两个周期交叉时，这种潜在的不一致性就会出现。
当然，这种行为是与处理器结构相关的，但是可移植的程序并不能使用任何处理器结构做出假设。
	要解决线程间的同步问题，就要使用锁。保证对于一个修改的动作是独占的，在此期间不可进行读取等操作。
	当两个或多个线程视图在同一时间修改同一变量时，也需要进行同步。比如在进行变量累加的过程中，可能一个线程已经修改了对象的
值，但是还没有进行回写，另一个线程这时又读取原值进行操作，此时会出现错误。
	在现代计算机系统中，存储器访问需要多个总线周期，多处理器的总线周期通常在多个处理器上是交叉的，所以无法保证数据是顺序
一致的。
	1.互斥量
	可以通过使用pthread的互斥接口保护数据，确保同一时间只有一个线程访问数据。互斥量mutex从本质上说是一把锁，在访问共享资源前对互
斥量进行加锁，在访问完成以后释放互斥量上的锁。
	互斥变量用pthread_mutex_t数据类型来表示，在使用互斥量以前，必须首先对它进行初始化，可以把它设置为常量
PTHREAD_MUTEX_INITIALIZE(只对静态分配的互斥量)，也可以通过pthread_mutex_init函数进行初始化。如果动态地分配互斥量(比如malloc)，那么
在释放内存前需要调用pthread_mutex_destroy.
	可以使用pthread_mutex_lock/unlock进行加减锁。如果共享区已被加锁，则其他线程会挂起等待；如果不希望被阻塞，可以使用
pthread_mutex_trylock尝试对互斥量进行加锁。如果互斥量未锁，则加锁，返回0；否则加锁失败返回EBUSY。
	
	2.避免死锁
	如果一个线程视图对一个互斥量加锁两次，那么它自身就会陷入死锁状态；使用互斥量时，还有其他更不明显的方式也能产生死锁。
可以通过小心地控制互此量加锁的顺序来避免死锁的发生。“只有在一个线程试图以与另一个线程相反的顺序锁住互斥量时，才可能出现死锁”。
	
	3.读写锁
	读写锁与互斥量类似，不过读写锁允许更高的并行性。读写锁可以有三种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。
一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。
    虽然读写锁的实现各不相同，但是当读写锁处于读模式锁住状态时，如果有另外的线程视图以写模式加锁，读写锁通常会阻塞随后的读模
式锁请求，这样可以避免读模式锁长期占用，而等待的写模式锁一直得不到满足。
    读写锁非常适合于对数据结构读的次数远远大于写的情况。
	pthread_rwlock_init()/pthread_rwlock_destroy()   pthread_rwlock_t.
	在读模式下锁定读写锁，需要调用pthread_rwlock_rdlock();要在写模式下锁定读写锁，需要调用pthread_rwlock_wrlock().不管
以何方式加锁，都可以使用pthread_rwlock_unlock进行解锁。
	在实现读写锁的时候可能会对共享模式下可获取的锁的数量进行限制，所以需要检查pyhrad_rwlock_rdlock()的返回值。
	
	4.条件变量
	条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥变量一起使用时，允许线程
以无竞争的方式等待特定的条件发生。
	条件本身是由互此量保护的。线程在改变条件状态前必须首先锁住互斥量，其他线程在获得互斥量之前不会察觉到这种改变，因为
必须锁定互斥量以后才能计算条件。
	条件变量使用前必须进行初始化，和互斥量类似也有两种初始化方式:pthread_cond_init()/PTHREAD_COND_INITIALIZER。
	在释放底层的内存空间之前，可以使用pthread_mutex_destroy函数对条件变量进行去初始化。
	调用pthread_cond_signal或者pthread_cond_broadcast，也称为向线程或条件发送信号。“必须注意一定要在改变状态条件以后再
	给线程发送信号。”
	条件是工作队列的状态。用互斥量保护条件，在while循环中判断条件。把消息放到工作队列时，需要占有互此量，单项等待线程发送信号时
并不需要占有互此量。	

========================================================================================================
			12	线程控制
	1.线程属性
	pthread_attr_t。线程还有其他的一些属性，这些属性并没有在pthread_attr_t结构中表达：可取消状态，可取消类型，并发度。
    并发度：控制着用户级线程可以映射的内核线程或进程的数目。如果OS的内核线程和用户线程是一对多或多对多的话，那么在给定的时间内增加
可运行的用户级线程数，可能会改善性能。pthread_setconcurrency()可以用于提示系统，表明希望的并发度。
    线程安全的：如果一个函数在同一时刻可以被多个线程安全调用，就成该函数是线程安全的。
    2.线程私有数据
    进程中的所有线程都可以访问进程的整个地址空间。除了使用寄存器以外，线程没有办法阻止其他线程访问它的数据，线程私有数据也不例外。
虽然底层的实现部分并不能阻止这种访问能力，但是管理线程私有数据的函数可以提高线程间的数据独立性。
    在分配线程私有数据之前，需要创建与该数据关联的“键”。这个键将用于获取对线程私有数据的访问权。pthread_key_create().
    #include <pthread.h>
    int pthread_key_create(pthread_key_t* key,void (*destructor)(void*));
    创建的key存放在指向的内存单元里面，这个键可以被进程中的所有线程使用，但是每个线程把这个键与不同的线程私有数据地址进行关联。
    创建新键时，每个线程的数据地址设置为null值。在创建key的时候，可以同时指定它的析构函数。当线程退出的时候，析构函数将按照定
被定义的顺序被调用。

	  pthread_sigmask - examine and change mask of blocked signals
SYNOPSIS
       #include <signal.h>
       int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);

       Compile and link with -pthread.

       5.线程和fork
       当线程调用fork时，就为子进程创建了整个进程地址空间的副本。子进程通过继承整个地址空间的副本，也从父进程哪里继承了所有mutex,
读写锁和条件变量的状态。
	pthread_atfork()

	6.线程和I/O
	使用pthread/pwrite函数会很有帮助，因为进程中所有线程共享相同的文件描述符。
       #define _XOPEN_SOURCE 500
       #include <unistd.h>
       ssize_t pread(int fd, void *buf, size_t count, off_t offset);
       ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);

DESCRIPTION
       pread() reads up to count bytes from file descriptor fd at offset  off-
       set  (from the start of the file) into the buffer starting at buf.  The
       file offset is not changed.

       pwrite() writes up to count bytes from the buffer starting  at  buf  to
       the  file  descriptor  fd  at  offset  offset.   The file offset is not
       changed.
       pread()使偏移量的设定和数据的读取成为一个原子操作。在多线程中，如果分开使用lseek()和read()/write(),可能在调用
read/write之前，其他的线程就又调用了lseek()，进而导致读取错误的文件位置。


	在UNIX中，线程提供了分解并发任务的一种替代模型。它的同步问题，应该十分注意。


	