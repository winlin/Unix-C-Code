
	   一个进程不能简单地将自己的内存空间地址传递给其他进程，这是因为LINUX系统的 内存保护机制/内存映射机制 造成的。
	   使用 shm_open 函数创建一个共享内存的长度是0，一般需要马上调用 ftruncate 函数调整它的大小。
	实际上，一个共享内存区对应着特殊文件系统 shm 中的一个文件，一般来说，这个文件系统挂在于 /dev/shm下。创建一个
	shm以后我们可以在该目录下找到创建的文件。
	
        使用共享内存的关键在于理解 mmap 函数，本质上，它是一个将已打开的文件映射到当前进程内存空间的函数，由于共享内存区域也是以
    文件描述符的形式出现，所以可以使用 mmap 函数 将一个共享内存空间当成文件映射到进程地址空间中 。
    	
	void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);
     如果 flags 为 MAP_ANONYMOUS，则mmap可以进行“匿名映射”，这时有的系统上文件描述符为 -1，也就是说“不需要打开文件”就可已进行映射。
     这种映射只能用于共享内存，可称之为“匿名共享内存”。

     对共享内存的基本使用过程如下：
	非匿名共享内存：
		1.某个进程使用 shm_open 函数创建一个共享内存区
		2.其他要进行通讯的进程使用 shm_open 函数打开这个共享内存区
		  ( int shm_open(const char *name, int oflag, mode_t mode); 直接把共享内存对应的文件路径传进去即可 )
		3.各个进程分别使用 mmap 将共享内存映射到自己的虚拟地址空间
		4.各个进程分别对映射得到的内存区域进行操作

	匿名共享内存：
		1.父进程匿名映射一个共享内存区域到自己的虚拟地址空间
		2.父进程创建子进程
		3.父子进程使用同样的内存首地址来操作共享内存区

