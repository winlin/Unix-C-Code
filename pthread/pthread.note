1.线程的分离状态
	当创建线程时所用的线程属性对象的分离状态是 PTHREAD_CREATE_JOINABLE 时，线程运行结束后不会自动清理所占用的资源，直到对它调用了
     pthread_join()函数。在这期间，线程虽然运行结束，但是用于管理它的数据仍然存在，类似与僵尸进程的概念。如果，创建线程时属性指定的分离
     状态为 PTHREAD_CREATE_DETACHED ,我们称线程处于“分离状态”。这种状态下，线程结束后会自动清理所占用的资源，如果对它调用pthread_join()
     就会返回错误。
	默认情况下创建的线程是处于未分离状态的，在创建以后可以调用 pthread_detach() 将本线程设置为分离状态。pthread_detach() 不会导致
     调用者阻塞，也不会导致所操作的线程结束。如果调用pthread_detach()时 线程已经结束，则会清理其所占用的资源。
       总上，对于创建时未指定 分离 状态的线程，必须调用 pthread_join/pthread_detach 否则就会产生 “僵尸线程”。

2.线程和进程的一个重要区别
	线程没有像进程那样的父子关系，它们仅属于同一个进程的“同组”关系。在POSIX模型中，主线程创建A线程，A线程创建线程B，AB之间没有父子关系
     两者等价。另外，pthread_join 函数可以由任何一个同组的线程发起，不一定是主线程。
        注意：如果主线程退出，那么所有的线程也会退出。

3.保证线程间同步的方法
	1.信号量
	2.互斥体
	3.条件变量
	4.读写锁


	互斥体：从概念上来说互斥体类似于一个二值信号等，即初始值为1的信号量。互斥体被获得以后就不能再被获取，因此对互斥体的获取和操作常常
	       称为 加锁 与 解锁 操作。但实际上，POSIX互斥体与信号量具有一些不同的特性，比如互斥体有“拥有者”者的概念，也就是说，互斥体只能
	       由获取它的线程进行释放操作，如果违反这一原则，则结果是未定义的。互斥体在实现上可能比二值信号灯更有效率，因此，在能够使用互斥体
	       的地方要尽量使用互斥体。
	       pthread_mutex_t 
	       pthread_mutex_init()
	       有时候，我们会设置一定的延迟时间，因为由于计算机的速度太快，如果没有认为的延迟，则对临界资源的访问将在很短的时间内完成，
	       背其他线程打断的概率非常小，这也是实际中出现的情况，设置延迟，只是增加可能性。


        条件变量：我们需要一种方法，使得当线程在等待满足某些条件时进入睡眠状态，一旦满足条件，线程就应该被唤醒继续执行。这个方法就是使用
		 POSIX 条件变量。所以，我们可以使用条件变量来实现让主线程等待所有子线程到达某种状态才继续执行等情况。
		 注意：条件变量要和互斥量连用。
		 pthread_cond_wait()函数的具体操作过程很重要：先解锁互斥量，然后等待条件变量发送的信号，接收到信号以后在加锁互斥量，
				函数退出。在等待的过程中其他线程就会获得互斥锁，进行相应的执行。
		 


    注意：在使用多线程的程序中，不可以再像多进程那样，共用一个缓冲区；另外，主线程里面也不可以关闭打开的文件描述符/socket套接字
	  因为，线程并不会增加描述符引用计数。


	  
    线程池：虽然创建一个线程已经比创建一个进程占用更少的资源，但是仍然存在效率影响。在很多解决方案中，应用程序初始化时就会创建一批
	   线程，然后每个线程都从任务队列中提取任务执行，这种方案称为线程池。线程池的实现依赖于很多关键设计，如任务队列的设计，任务
	   数据的表示等。